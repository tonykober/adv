<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>防禦戰線：廢墟行動 v10.10</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            touch-action: none;
            font-family: 'Rajdhani', 'Noto Sans TC', sans-serif;
            user-select: none;
            color: #e2e8f0;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
        .hud-element {
            pointer-events: auto;
        }
        
        /* 準心 */
        #crosshair {
            position: absolute;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            z-index: 100;
            transition: width 0.1s, height 0.1s;
        }
        #crosshair .dot {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: #06b6d4;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px #06b6d4;
        }
        #crosshair .ring {
            position: absolute; inset: 0;
            border: 2px solid rgba(6, 182, 212, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.2);
        }
        #crosshair .line-h {
            position: absolute; top: 50%; left: -8px; right: -8px; height: 1px;
            background: linear-gradient(90deg, transparent, #06b6d4, transparent);
        }
        #crosshair .line-v {
            position: absolute; left: 50%; top: -8px; bottom: -8px; width: 1px;
            background: linear-gradient(180deg, transparent, #06b6d4, transparent);
        }

        /* 傷害數字 */
        .damage-text {
            position: absolute;
            color: white;
            font-weight: 800;
            font-size: 28px;
            font-family: 'Rajdhani', 'Noto Sans TC', monospace;
            pointer-events: none;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.8);
            animation: floatUp 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 20;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-10px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-40px) scale(1); opacity: 0; }
        }

        /* 全爆裂特效 */
        .burst-mode-active #uiLayer {
            box-shadow: inset 0 0 50px rgba(234, 179, 8, 0.4), inset 0 0 100px rgba(234, 179, 8, 0.2);
        }
        .burst-banner {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%) translateY(-20px);
            width: 100%; max-width: 600px;
            height: 40px;
            background: linear-gradient(90deg, transparent, rgba(234, 179, 8, 0.8), transparent);
            display: flex; items-center; justify-center;
            color: #fff; font-weight: 900; font-family: 'Rajdhani', sans-serif; letter-spacing: 5px; font-size: 24px;
            opacity: 0; pointer-events: none; transition: all 0.3s;
            clip-path: polygon(0 0, 100% 0, 95% 100%, 5% 100%);
        }
        .burst-mode-active .burst-banner {
            opacity: 1; transform: translateX(-50%) translateY(0);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        /* HUD 面板 */
        .hud-panel {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9) 0%, rgba(15, 23, 42, 0.7) 100%);
            border: 1px solid rgba(56, 189, 248, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            padding: 12px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .burst-mode-active .hud-panel {
            border-color: rgba(234, 179, 8, 0.6);
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.2);
        }
        .hud-panel-left {
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
            border-bottom-right-radius: 0;
        }
        .hud-panel-right {
            clip-path: polygon(0 0, 100% 0, 100% 100%, 20px 100%, 0 calc(100% - 20px));
            border-bottom-left-radius: 0;
        }
        .hud-panel::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, #06b6d4, transparent);
            opacity: 0.7;
        }
        .burst-mode-active .hud-panel::before {
            background: linear-gradient(90deg, transparent, #eab308, transparent);
        }

        /* 按鈕 */
        .tech-btn {
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid #06b6d4;
            color: #22d3ee;
            font-family: 'Rajdhani', 'Noto Sans TC', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .tech-btn:hover:not(:disabled) {
            background: #06b6d4; color: #000;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.6);
        }
        .tech-btn:disabled {
            border-color: #475569; color: #64748b; background: rgba(0,0,0,0.2);
            cursor: not-allowed;
        }

        /* 警告閃爍 */
        .warning-text { animation: blinkRed 1s infinite; }
        @keyframes blinkRed { 50% { color: #ef4444; opacity: 0.5; } }

        /* 掃描線 */
        .scanlines {
            background: linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            position: absolute; inset: 0; pointer-events: none; opacity: 0.2; z-index: 5;
        }
    </style>
</head>
<body class="bg-slate-950 overflow-hidden">

    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    
    <!-- 準心 -->
    <div id="crosshair">
        <div class="dot"></div>
        <div class="ring"></div>
        <div class="line-h"></div>
        <div class="line-v"></div>
    </div>

    <div class="ui-layer" id="uiLayer">
        
        <!-- 全爆裂頂部條 -->
        <div class="burst-banner flex items-center justify-center">
            <span class="mr-4">///</span> 全爆裂模式啟動 <span class="ml-4">///</span>
        </div>

        <!-- 頂部資訊列 -->
        <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-50">
            <div class="flex flex-col gap-1">
                <div class="flex items-center gap-2">
                    <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                    <span class="text-xs text-cyan-400 font-mono tracking-widest font-bold">系統連線正常</span>
                </div>
                <div class="text-[10px] text-slate-500 font-mono tracking-wider">區域：DUSK-9 // 座標：35.68.95</div>
            </div>

            <!-- BOSS 血條 -->
            <div id="bossBarContainer" class="hidden w-[400px] relative mt-2">
                <div class="flex justify-between text-[10px] text-red-400 font-bold mb-1 tracking-[0.2em]">
                    <span>警告：暴君級反應</span>
                    <span id="bossHpPercent">100%</span>
                </div>
                <div class="h-4 bg-slate-900/80 border border-red-900 skew-x-[-15deg] p-[2px]">
                    <div id="bossHpBar" class="h-full bg-gradient-to-r from-red-900 via-red-600 to-red-500 w-full transition-all duration-100"></div>
                </div>
            </div>

            <button id="pauseBtn" class="hud-element w-10 h-10 border border-slate-700 bg-slate-900/50 hover:bg-cyan-900/30 flex items-center justify-center transition-colors">
                <div class="flex gap-1">
                    <div class="w-1 h-4 bg-cyan-500"></div>
                    <div class="w-1 h-4 bg-cyan-500"></div>
                </div>
            </button>
        </div>

        <!-- 底部 HUD 區域 -->
        <div class="absolute bottom-0 w-full h-[250px] flex justify-between items-end px-4 pb-6 pointer-events-none" id="gameHud" style="opacity: 0; transition: opacity 0.5s;">
            <!-- 左側戰術面板 -->
            <div class="hud-panel hud-panel-left w-[220px] h-[160px] flex gap-3 pointer-events-auto items-end">
                <div class="h-full flex flex-col items-center justify-end gap-2 shrink-0">
                    <div class="relative w-3 h-[90px] bg-slate-900 border border-slate-700 rounded-sm overflow-hidden">
                         <div id="burstBarFill" class="absolute bottom-0 w-full bg-gradient-to-t from-yellow-600 to-yellow-300 transition-all duration-100" style="height: 0%"></div>
                    </div>
                    <span class="text-[10px] text-yellow-500 font-bold tracking-widest writing-vertical-lr" style="writing-mode: vertical-rl;">爆裂</span>
                </div>
                <div class="flex flex-col justify-end w-full gap-2 pb-1">
                    <div class="flex items-center gap-2 border-b border-slate-700 pb-2 mb-1">
                        <div class="w-8 h-8 bg-cyan-900/30 border border-cyan-500/30 flex items-center justify-center text-cyan-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>
                        </div>
                        <div>
                            <div class="text-[10px] text-slate-400 font-mono">操作員</div>
                            <div class="text-base text-white font-bold leading-none tracking-wider">CMD-01</div>
                        </div>
                    </div>
                    <div class="w-full">
                        <div class="flex justify-between text-[10px] text-cyan-300 mb-1 font-mono">
                            <span>裝甲完整度</span>
                            <span id="hpText">100%</span>
                        </div>
                        <div class="h-2 bg-slate-900 border border-slate-600 skew-x-[-10deg] p-[1px]">
                            <div id="playerHpBar" class="h-full bg-cyan-500 w-full transition-all duration-200 shadow-[0_0_10px_cyan]"></div>
                        </div>
                    </div>
                    <button id="burstBtn" class="hud-element w-full py-1 mt-1 text-xs font-bold bg-yellow-500/10 border border-yellow-600/50 text-yellow-500 hover:bg-yellow-500 hover:text-black transition-all disabled:opacity-30 disabled:hover:bg-transparent disabled:hover:text-yellow-500">
                        啟動爆裂 [A]
                    </button>
                </div>
            </div>

            <!-- 右側火控面板 -->
            <div class="hud-panel hud-panel-right w-[220px] h-[160px] flex flex-col justify-between pointer-events-auto text-right">
                <div class="border-b border-slate-700 pb-2 mb-2">
                    <div class="text-[10px] text-slate-400 font-mono tracking-widest">武器系統</div>
                    <div id="weaponName" class="text-xl font-black italic text-cyan-400 tracking-wider truncate">突擊步槍</div>
                </div>
                <div class="flex flex-col items-end">
                    <div id="reloadIndicator" class="hidden text-red-500 font-bold tracking-[0.2em] animate-pulse text-xs mb-1">裝填中...</div>
                    <div class="flex items-baseline gap-1">
                        <span id="ammoDisplay" class="text-5xl font-bold text-white tracking-tighter tabular-nums leading-none">60</span>
                        <span class="text-lg text-slate-500 font-mono">/ <span id="maxAmmoDisplay">60</span></span>
                    </div>
                </div>
                <div class="flex justify-end gap-1 mt-auto pt-2">
                    <div class="w-6 h-1 bg-cyan-500/50"></div>
                    <div class="w-3 h-1 bg-cyan-500/30"></div>
                    <div class="w-1 h-1 bg-cyan-500/10"></div>
                </div>
            </div>
        </div>

        <!-- 遊戲開始畫面 -->
        <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-950/90 z-50 pointer-events-auto backdrop-blur-md">
            <div class="relative mb-2 pr-4 pb-4">
                <h1 class="text-8xl font-black text-transparent bg-clip-text bg-gradient-to-b from-white to-cyan-400 italic tracking-tight leading-normal" style="padding-right: 20px;">防禦戰線</h1>
                <div class="absolute bottom-4 right-0 text-xl text-cyan-600 font-black italic tracking-widest">v10.10</div>
            </div>
            <p class="text-cyan-600 mb-10 text-xl font-bold tracking-[0.5em] uppercase">代號：廢墟</p>
            <div class="flex items-center gap-4 mb-8 p-4 bg-slate-900/50 border border-slate-700 rounded">
                <span class="text-slate-400 font-bold">BOSS 戰計時</span>
                <button id="decTime" class="w-8 h-8 bg-slate-800 text-cyan-400 border border-slate-600 hover:bg-cyan-900">-</button>
                <input type="number" id="bossTimeInput" value="30" class="w-16 bg-transparent text-center text-white border-b border-cyan-500 outline-none font-mono text-xl" readonly>
                <button id="incTime" class="w-8 h-8 bg-slate-800 text-cyan-400 border border-slate-600 hover:bg-cyan-900">+</button>
            </div>
            <button id="startBtn" class="tech-btn px-16 py-4 text-2xl tracking-widest">開始任務</button>
            <div class="absolute bottom-8 text-slate-600 font-mono text-xs">系統連線安全 // 伺服器：TW-01</div>
        </div>

        <!-- 暫停與結算 -->
        <div id="pauseScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-950/95 z-50 hidden pointer-events-auto backdrop-blur-lg">
            <h2 class="text-5xl text-white font-bold mb-12 italic tracking-widest">暫停</h2>
            <button id="resumeBtn" class="tech-btn w-64 py-4 mb-4 text-xl">繼續</button>
            <button id="quitBtn" class="tech-btn w-64 py-4 text-xl border-red-500 text-red-500 hover:bg-red-500/10">放棄任務</button>
        </div>
        <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-950/90 z-50 hidden pointer-events-auto backdrop-blur-md">
            <div id="endCard" class="bg-slate-900/80 border-y-2 border-slate-500 w-full py-12 flex flex-col items-center">
                <h1 id="endTitle" class="text-6xl font-black mb-2 tracking-widest italic text-white">任務失敗</h1>
                <p id="endSubtitle" class="text-slate-400 text-xl tracking-[0.5em] mb-8">訊號中斷</p>
                <div class="text-4xl font-mono text-cyan-400 mb-10" id="endScore">分數: 0</div>
                <button id="gameOverHomeBtn" class="tech-btn px-12 py-3 text-lg">返回基地</button>
            </div>
        </div>
    </div>

    <script>
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        const CROSSHAIR = document.getElementById('crosshair');
        const CROSSHAIR_DOT = CROSSHAIR.querySelector('.dot');
        const CROSSHAIR_RING = CROSSHAIR.querySelector('.ring');
        
        const WEAPONS = {
            AR: { id: 'AR', name: '突擊步槍', fireRate: 6, damage: 15, reloadSpeed: 0.8, mag: 60, color: '#06b6d4', spread: 15, count: 1, speed: 45 },
            MG: { id: 'MG', name: '重機槍', fireRate: 3, damage: 8, reloadSpeed: 2.5, mag: 300, color: '#d946ef', spread: 25, count: 1, speed: 50 },
            SG: { id: 'SG', name: '戰術散彈', fireRate: 40, damage: 12, reloadSpeed: 0.2, mag: 10, color: '#facc15', spread: 40, count: 8, speed: 35 },
            SR: { id: 'SR', name: '狙擊步槍', damage: 300, reloadSpeed: 0.5, mag: 6, color: '#f97316', spread: 5, count: 1, speed: 80, chargeTime: 24 }
        };

        const GAME_CONFIG = {
            maxHp: 100,
            enemyHp: 10,
            enemyDamage: 2,
            burstDamageMult: 3,
            burstDuration: 600,
            enemySpawnRate: 60, 
            maxEnemies: 6,
            bossSpawnFrames: 1800 
        };

        let gameState = {
            status: 'START',
            score: 0,
            frames: 0,
            player: {
                hp: GAME_CONFIG.maxHp,
                weapon: WEAPONS.AR,
                ammo: WEAPONS.AR.mag,
                maxAmmo: WEAPONS.AR.mag,
                isHiding: true,
                burstGauge: 0, 
                isBurstActive: false,
                burstTimer: 0,
                weaponHeat: 0,
                currentWeaponCharge: 0
            },
            input: { isDown: false, x: 0, y: 0, currentRecoilX: 0, currentRecoilY: 0 }, 
            enemies: [],
            projectiles: [],
            particles: [],
            drops: [], 
            cameraShake: 0,
            boss: null
        };

        let MIDGROUND_DEBRIS = [];

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            const startInput = (x, y, target) => {
                if (gameState.status !== 'PLAYING') return;
                if (target && target.closest('.hud-element')) return;
                gameState.input.isDown = true;
                gameState.input.x = x;
                gameState.input.y = y;
                gameState.player.isHiding = false;
                CROSSHAIR.style.display = 'block';
            };
            const moveInput = (x, y) => { gameState.input.x = x; gameState.input.y = y; };
            const endInput = () => {
                gameState.input.isDown = false;
                gameState.player.isHiding = true;
                gameState.player.currentWeaponCharge = 0; 
                CROSSHAIR.style.display = 'none';
            };

            window.addEventListener('mousedown', (e) => startInput(e.clientX, e.clientY, e.target));
            window.addEventListener('mousemove', (e) => moveInput(e.clientX, e.clientY));
            window.addEventListener('mouseup', endInput);
            
            window.addEventListener('touchstart', (e) => startInput(e.touches[0].clientX, e.touches[0].clientY, e.target), {passive: false});
            window.addEventListener('touchmove', (e) => { e.preventDefault(); moveInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
            window.addEventListener('touchend', endInput);

            window.addEventListener('keydown', (e) => {
                if ((e.key === 'a' || e.key === 'A') && gameState.status === 'PLAYING') activateBurst();
                if (e.key === 'Escape') togglePause();
            });

            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('gameOverHomeBtn').addEventListener('click', quitGame);
            document.getElementById('burstBtn').addEventListener('click', activateBurst);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('resumeBtn').addEventListener('click', togglePause);
            document.getElementById('quitBtn').addEventListener('click', quitGame);
            
            const timeInput = document.getElementById('bossTimeInput');
            document.getElementById('decTime').addEventListener('click', () => timeInput.value = Math.max(5, parseInt(timeInput.value) - 5));
            document.getElementById('incTime').addEventListener('click', () => timeInput.value = Math.min(300, parseInt(timeInput.value) + 5));

            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() { 
            CANVAS.width = window.innerWidth; 
            CANVAS.height = window.innerHeight; 
            
            // Generate Midground Debris (Ruins)
            MIDGROUND_DEBRIS = [];
            for (let i = 0; i < 40; i++) {
                MIDGROUND_DEBRIS.push({
                    x: (Math.random() - 0.5) * 2000, 
                    y: Math.random() * 150, // Distance from horizon
                    z: Math.random() * 1000 + 50,
                    width: 30 + Math.random() * 40,
                    height: 20 + Math.random() * 30,
                    color: Math.random() > 0.6 ? '#334155' : '#1e293b',
                    rotation: (Math.random() - 0.5) * 0.2 // Slight tilt
                });
            }
            MIDGROUND_DEBRIS.sort((a, b) => b.z - a.z); // Draw further ones first
        }

        function startGame() {
            resizeCanvas(); 
            const timeVal = parseInt(document.getElementById('bossTimeInput').value) || 30;
            GAME_CONFIG.bossSpawnFrames = timeVal * 60;
            gameState = {
                ...gameState,
                status: 'PLAYING', score: 0, frames: 0, enemies: [], projectiles: [], particles: [], drops: [], boss: null, bossDefeated: false
            };
            gameState.player.hp = GAME_CONFIG.maxHp;
            gameState.player.weapon = WEAPONS.AR;
            gameState.player.ammo = WEAPONS.AR.mag;
            gameState.player.maxAmmo = WEAPONS.AR.mag;
            gameState.player.burstGauge = 0;
            gameState.player.isBurstActive = false;
            gameState.player.currentWeaponCharge = 0;
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('gameHud').style.opacity = 1;
            document.getElementById('bossBarContainer').classList.add('hidden');
            document.body.classList.remove('burst-mode-active');
            updateUI();
        }

        function togglePause() {
            if (gameState.status === 'PLAYING') {
                gameState.status = 'PAUSED';
                document.getElementById('pauseScreen').classList.remove('hidden');
            } else if (gameState.status === 'PAUSED') {
                gameState.status = 'PLAYING';
                document.getElementById('pauseScreen').classList.add('hidden');
            }
        }

        function quitGame() {
            gameState.status = 'START';
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('gameHud').style.opacity = 0;
            document.getElementById('startScreen').classList.remove('hidden');
            document.body.classList.remove('burst-mode-active');
        }

        function updateCrosshairPosition() {
            if (!gameState.input.isDown) return;
            let recoil = gameState.player.weaponHeat * 1.5;
            gameState.input.currentRecoilX = (Math.random() - 0.5) * recoil;
            gameState.input.currentRecoilY = (Math.random() - 0.5) * recoil;
            
            let finalX = gameState.input.x + gameState.input.currentRecoilX;
            let finalY = gameState.input.y + gameState.input.currentRecoilY;
            
            CROSSHAIR.style.left = finalX + 'px';
            CROSSHAIR.style.top = finalY + 'px';

            const p = gameState.player;
            if (p.isBurstActive) {
                CROSSHAIR.style.width = '60px'; CROSSHAIR.style.height = '60px';
                CROSSHAIR_RING.style.borderColor = '#eab308';
                CROSSHAIR_DOT.style.backgroundColor = '#eab308';
            } else if (p.weapon.id === 'SR') {
                let size = 100 - (p.currentWeaponCharge * 60); 
                CROSSHAIR.style.width = size + 'px'; CROSSHAIR.style.height = size + 'px';
                CROSSHAIR_RING.style.borderColor = '#f97316';
                CROSSHAIR_DOT.style.backgroundColor = '#f97316';
            } else {
                let heatScale = Math.min(20, p.weaponHeat);
                CROSSHAIR.style.width = (40 + heatScale) + 'px';
                CROSSHAIR.style.height = (40 + heatScale) + 'px';
                CROSSHAIR_RING.style.borderColor = '#06b6d4';
                CROSSHAIR_DOT.style.backgroundColor = '#06b6d4';
            }
        }

        function gameLoop() {
            if (gameState.status === 'PLAYING') { update(); draw(); }
            requestAnimationFrame(gameLoop);
        }

        function update() {
            gameState.frames++;
            updateCrosshairPosition();
            updatePlayer();
            spawnEnemies(); 
            updateEnemies();
            updateProjectiles();
            updateParticles();
            updateDrops();
            updateUI();
            if (gameState.cameraShake > 0) gameState.cameraShake *= 0.9;
        }

        function updatePlayer() {
            const p = gameState.player;
            const w = p.weapon;
            if (w.chargeTime) { 
                if (!p.isHiding && p.ammo > 0) {
                    p.currentWeaponCharge += 1 / w.chargeTime;
                    if (p.isBurstActive) p.currentWeaponCharge += 0.05;
                    if (p.currentWeaponCharge >= 1) { fireWeapon(); p.currentWeaponCharge = 0; }
                } else p.currentWeaponCharge = 0;
            } else if (!p.isHiding && p.ammo > 1) { 
                let fireRate = p.isBurstActive ? Math.max(1, Math.floor(w.fireRate * 0.5)) : w.fireRate;
                if (gameState.frames % fireRate === 0) fireWeapon();
            }
            if (p.isHiding && p.ammo < p.maxAmmo) {
                let speed = w.reloadSpeed; if (p.isBurstActive) speed = 5;
                p.ammo += speed; if (p.ammo > p.maxAmmo) p.ammo = p.maxAmmo;
            }
            if (p.weaponHeat > 0) p.weaponHeat *= 0.85;
            if (p.isBurstActive) {
                p.burstTimer--;
                if (p.burstTimer <= 0) {
                    p.isBurstActive = false; document.body.classList.remove('burst-mode-active');
                }
            }
        }

        function fireWeapon() {
            const p = gameState.player;
            const w = p.weapon;
            p.ammo--;
            p.weaponHeat = p.isBurstActive ? 20 : 10;
            gameState.cameraShake = p.isBurstActive ? 5 : 2;
            if (p.isBurstActive) p.ammo += 0.9; 

            const startX = CANVAS.width / 2 + 50; 
            const startY = CANVAS.height - 180; 
            
            let projectileCount = p.isBurstActive ? (w.id === 'SG' ? 12 : 3) : w.count;
            let aimX = gameState.input.x + gameState.input.currentRecoilX;
            let aimY = gameState.input.y + gameState.input.currentRecoilY;

            for(let i=0; i<projectileCount; i++) {
                let spread = p.isBurstActive ? w.spread * 0.5 : w.spread;
                if(w.id === 'SR' && !p.isBurstActive) spread = 1;
                let tx = aimX + (Math.random() - 0.5) * spread;
                let ty = aimY + (Math.random() - 0.5) * spread;
                gameState.projectiles.push(new Projectile(startX, startY, tx, ty, false, w));
            }
        }

        function activateBurst() {
            if (gameState.player.burstGauge >= 100 && !gameState.player.isBurstActive) {
                gameState.player.isBurstActive = true;
                gameState.player.burstTimer = GAME_CONFIG.burstDuration;
                gameState.player.burstGauge = 0;
                gameState.player.ammo = gameState.player.maxAmmo;
                document.body.classList.add('burst-mode-active');
                gameState.cameraShake = 20;
                gameState.projectiles = gameState.projectiles.filter(p => !p.isEnemy); 
            }
        }

        class Projectile {
            constructor(x, y, tx, ty, isEnemy, weaponData) {
                this.x = x; this.y = y; this.startX = x; this.startY = y;
                this.isEnemy = isEnemy; this.active = true; this.weapon = weaponData || {};
                const dx = tx - x; const dy = ty - y; const dist = Math.sqrt(dx*dx + dy*dy);
                this.speed = isEnemy ? 8 : (this.weapon.speed || 40);
                if (gameState.player.isBurstActive && !isEnemy) this.speed = 70; 
                this.vx = (dx / dist) * this.speed; this.vy = (dy / dist) * this.speed;
                this.scale = isEnemy ? 0.2 : 1.0; this.progress = 0; this.totalDist = dist; 
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                const dCurrent = Math.sqrt((this.x - this.startX)**2 + (this.y - this.startY)**2);
                this.progress = dCurrent / this.totalDist;
                
                if (this.isEnemy) {
                    this.scale = 0.2 + (this.progress * 1.5);
                    if (this.progress >= 0.95) {
                        this.active = false;
                        if (gameState.player.isHiding) {
                            createDamageText(CANVAS.width/2 + (Math.random()*60-30), CANVAS.height - 160, "防禦", false);
                            createParticle(this.x, this.y, 'spark');
                        } else {
                            gameState.player.hp -= GAME_CONFIG.enemyDamage;
                            gameState.cameraShake = 5;
                            document.body.classList.add('warning-flash');
                            setTimeout(() => document.body.classList.remove('warning-flash'), 100);
                            createParticle(this.x, this.y, 'explosion');
                            if (gameState.player.hp <= 0) gameOver();
                        }
                    }
                } else {
                    let hit = false;
                    for (let i = 0; i < gameState.drops.length; i++) {
                        let drop = gameState.drops[i];
                        if (Math.hypot(this.x - drop.screenX, this.y - drop.screenY) < 50) {
                            switchWeapon(drop.type); gameState.drops.splice(i, 1); hit = true; break;
                        }
                    }
                    if (!hit && gameState.boss) {
                        if (Math.hypot(this.x - gameState.boss.x, this.y - gameState.boss.y) < gameState.boss.radius) {
                             let dmg = this.getDmg();
                             gameState.boss.hp -= dmg;
                             gameState.player.burstGauge = Math.min(100, gameState.player.burstGauge + 0.5);
                             hit = true;
                             createDamageText(this.x, this.y, Math.floor(dmg));
                             createParticle(this.x, this.y, 'spark');
                             if (gameState.boss.hp <= 0) killBoss();
                        }
                    }
                    if (!hit) {
                        for (let enemy of gameState.enemies) {
                            if (enemy.dead) continue;
                            
                            // Foreground check only now
                            const isForegroundOccluded = (enemy.screenX < 200 || enemy.screenX > CANVAS.width - 200) && enemy.screenY > CANVAS.height * 0.6;
                            if (isForegroundOccluded) continue;

                            const hitRadius = Math.max(enemy.radius * enemy.scale * 3.0, 30); 
                            const dist = Math.hypot(this.x - enemy.screenX, this.y - enemy.screenY);
                            
                            if (dist < hitRadius) {
                                let dmg = this.getDmg();
                                enemy.hp -= dmg;
                                gameState.player.burstGauge = Math.min(100, gameState.player.burstGauge + 1.5); 
                                createDamageText(this.x, this.y, Math.floor(dmg));
                                createParticle(this.x, this.y, 'blood');
                                hit = true;
                                if (this.weapon.id === 'SR' || gameState.player.isBurstActive) createParticle(this.x, this.y, 'explosion'); 
                                if (enemy.hp <= 0) {
                                    enemy.dead = true; gameState.score += 100;
                                    createParticle(enemy.screenX, enemy.screenY, 'explosion');
                                }
                                break;
                            }
                        }
                    }
                    if (hit || this.progress >= 1.1) this.active = false;
                }
            }
            getDmg() {
                let base = this.weapon.damage || 1;
                if (gameState.player.isBurstActive) base *= GAME_CONFIG.burstDamageMult;
                return base;
            }
            draw() {
                CTX.save();
                CTX.translate(this.x, this.y);
                CTX.rotate(Math.atan2(this.vy, this.vx));
                if (this.isEnemy) {
                    CTX.fillStyle = '#ff0044';
                    CTX.shadowColor = 'red'; CTX.shadowBlur = 10;
                    CTX.beginPath(); CTX.arc(0, 0, 8 * this.scale, 0, Math.PI * 2); CTX.fill();
                } else {
                    if (gameState.player.isBurstActive) {
                        CTX.fillStyle = '#fff'; CTX.shadowColor = 'gold'; CTX.shadowBlur = 15;
                        CTX.fillRect(-40, -4, 80, 8); 
                    } else if (this.weapon.id === 'SR') {
                        CTX.fillStyle = '#f97316'; CTX.fillRect(-30, -3, 60, 6); CTX.shadowColor = '#f97316'; CTX.shadowBlur = 10;
                    } else {
                        CTX.fillStyle = this.weapon.color; CTX.shadowColor = this.weapon.color; CTX.shadowBlur = 5; 
                        CTX.fillRect(-15, -2, 30, 4);
                    }
                }
                CTX.restore();
            }
        }

        class Enemy {
            constructor(spawnType = 'normal') {
                this.hp = GAME_CONFIG.enemyHp; this.maxHp = GAME_CONFIG.enemyHp;
                this.attackTimer = 200 + Math.random()*200; this.state='idle';
                this.timeOffset = Math.random()*100;
                this.rotation = 0;
                this.radius = 60;
                
                this.spawnType = spawnType;
                this.z = 1500; 
                this.isOccluded = false;
                
                if (spawnType === 'drop') {
                    this.x = (Math.random()-0.5)*400;
                    this.y = -800; 
                    this.targetY = (Math.random()-0.5)*300;
                    this.speedZ = 4 + Math.random();
                } else if (spawnType === 'flank') {
                    const side = Math.random() > 0.5 ? 1 : -1;
                    this.x = side * 1500;
                    this.y = (Math.random()-0.5)*300;
                    this.targetX = (Math.random()-0.5)*600;
                    this.speedZ = 3 + Math.random();
                } else {
                    this.x = (Math.random()-0.5)*800; 
                    this.y = (Math.random()-0.5)*300;
                    this.speedZ = 3 + Math.random();
                }
            }
            update() {
                if (this.spawnType === 'drop') {
                    if(this.y < this.targetY) this.y += 5; 
                    else {
                        const t = (gameState.frames + this.timeOffset)*0.03;
                        this.y += Math.cos(t)*1.5;
                    }
                } else if (this.spawnType === 'flank') {
                     if(Math.abs(this.x - this.targetX) > 10) {
                         this.x += (this.targetX - this.x) * 0.02;
                     }
                     const t = (gameState.frames + this.timeOffset)*0.03;
                     this.y += Math.cos(t*1.3)*1.5;
                } else {
                    const t = (gameState.frames + this.timeOffset)*0.03;
                    this.x += Math.sin(t)*2; this.y += Math.cos(t*1.3)*1.5;
                }

                if(this.z>200) this.z-=this.speedZ;
                this.rotation += 0.05;

                // Update Occlusion State
                const focalLength = 600; const scale = focalLength / (focalLength + this.z);
                this.screenX = CANVAS.width/2 + this.x * scale;
                this.screenY = CANVAS.height/2 + this.y * scale;
                this.scale = scale;

                this.isOccluded = false;
                
                // Check Foreground Occlusion only
                if ((this.screenX < 200 || this.screenX > CANVAS.width - 200) && this.screenY > CANVAS.height * 0.6) {
                    this.isOccluded = true;
                }

                if (this.isOccluded) {
                    this.state = 'idle'; 
                    return; 
                }

                this.attackTimer--;
                if(this.attackTimer<50 && this.attackTimer>0) this.state='aiming';
                else if(this.attackTimer<=0) { this.state='attacking'; this.fire(); this.attackTimer = 200 + Math.random()*150; }
                else this.state='idle';
            }
            fire() {
                const targetY = CANVAS.height - 160; 
                const targetX = CANVAS.width / 2 + (Math.random()*60-30);
                gameState.projectiles.push(new Projectile(this.screenX, this.screenY, targetX, targetY, true));
            }
        }
        
        class Boss {
            constructor() { 
                this.x=CANVAS.width/2; 
                this.y=-1000; 
                this.targetY = CANVAS.height/3;
                this.radius=120; this.hp=3000; this.maxHp=3000; this.movePhase=0; 
                this.state = 'entering';
            }
            update() {
                if(this.state === 'entering') {
                    if(this.y < this.targetY) {
                        this.y += 8; // Faster entry
                    } else {
                        this.state = 'fighting';
                        this.y = this.targetY;
                        this.movePhase = Math.PI / 2; 
                        gameState.cameraShake = 20;
                    }
                } else {
                    this.movePhase+=0.01;
                    this.x = CANVAS.width/2 + Math.cos(this.movePhase)*200;
                    this.y = CANVAS.height/3 + Math.sin(this.movePhase*2)*50;
                    if(Math.random()<0.02) {
                         const targetY = CANVAS.height - 160; 
                         const targetX = CANVAS.width / 2 + (Math.random()*100-50);
                         gameState.projectiles.push(new Projectile(this.x, this.y, targetX, targetY, true));
                    }
                }
            }
        }

        class WeaponDrop {
            constructor() {
                const types=['AR','MG','SG','SR']; this.type=types[Math.floor(Math.random()*types.length)];
                this.data=WEAPONS[this.type]; 
                
                // Start high
                this.x = (Math.random() - 0.5) * 600; 
                this.y = -400 - Math.random() * 200; 
                this.z = 1000;
                this.life = 1000;

                // INVERTED Drift logic: If starts left (x<0), drift right (1). If starts right (x>0), drift left (-1).
                this.driftDir = this.x > 0 ? -1 : 1; 

                this.driftSpeedX = 1.0 + Math.random() * 0.8;
                this.fallSpeedY = 0.6;
            }
            update() {
                this.z -= 1.0; 
                this.x += this.driftSpeedX * this.driftDir; 
                this.y += this.fallSpeedY; 

                this.life--;
                const focalLength = 600; const scale = focalLength / (focalLength + this.z);
                this.screenX = CANVAS.width/2 + this.x * scale;
                this.screenY = CANVAS.height/2 + this.y * scale; 
                this.scale = scale;

                if (this.life <= 0 || this.z < 50 || this.screenY > CANVAS.height + 100 || this.screenX < -200 || this.screenX > CANVAS.width + 200) {
                    this.life = 0;
                    this.z = 0; 
                }
            }
            draw() {
                CTX.save(); CTX.translate(this.screenX, this.screenY);
                const s=60*this.scale;
                CTX.fillStyle = 'rgba(230, 230, 230, 0.8)';
                CTX.beginPath(); CTX.arc(0, -s*4, s*2.5, Math.PI, 0); CTX.fill();
                CTX.strokeStyle = '#94a3b8'; CTX.lineWidth = 1;
                CTX.beginPath();
                CTX.moveTo(-s*2.5, -s*4); CTX.lineTo(-s/2, -s/2); 
                CTX.moveTo(s*2.5, -s*4); CTX.lineTo(s/2, -s/2);   
                CTX.moveTo(0, -s*1.5); CTX.lineTo(0, -s/2);       
                CTX.stroke();
                CTX.fillStyle='#0f172a'; CTX.strokeStyle=this.data.color; CTX.lineWidth=3;
                CTX.beginPath(); CTX.rect(-s/2, -s/2, s, s); CTX.fill(); CTX.stroke();
                CTX.fillStyle='white'; CTX.font=`bold ${20*this.scale}px 'Rajdhani'`; CTX.textAlign='center'; CTX.fillText(this.data.id, 0, 8*this.scale);
                CTX.restore();
            }
        }

        function spawnEnemies() {
            if(gameState.frames>=GAME_CONFIG.bossSpawnFrames && !gameState.boss && !gameState.bossDefeated) {
                gameState.boss=new Boss(); document.getElementById('bossBarContainer').classList.remove('hidden');
            }
            if(gameState.boss) return;
            if(gameState.enemies.length<GAME_CONFIG.maxEnemies && Math.random()*1000<GAME_CONFIG.enemySpawnRate) {
                const r = Math.random();
                let type = 'normal';
                if(r > 0.7) type = 'flank';
                if(r > 0.9) type = 'drop';
                gameState.enemies.push(new Enemy(type));
            }
        }
        function updateEnemies() {
            if(gameState.boss) gameState.boss.update();
            for(let i=gameState.enemies.length-1;i>=0;i--) {
                let e=gameState.enemies[i]; e.update();
                if(e.dead || e.z<50) gameState.enemies.splice(i,1);
            }
        }
        function updateDrops() {
            if(gameState.drops.length<1 && Math.random()*1000<5) gameState.drops.push(new WeaponDrop());
            gameState.drops.forEach((d,i)=>{ d.update(); if(d.life<=0||d.z<50)gameState.drops.splice(i,1); });
        }
        function updateProjectiles() {
            gameState.projectiles.forEach((p,i)=>{ p.update(); if(!p.active) gameState.projectiles.splice(i,1); });
        }
        function killBoss() {
            gameState.boss=null; gameState.bossDefeated=true; gameState.score+=10000;
            document.getElementById('endTitle').innerText='任務完成';
            document.getElementById('endSubtitle').innerText='目標已殲滅';
            document.getElementById('endCard').className = 'bg-cyan-900/80 border-y-2 border-yellow-500 w-full py-12 flex flex-col items-center';
            gameOver();
        }
        function gameOver() {
            gameState.status='GAMEOVER';
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('endScore').innerText=`分數: ${gameState.score}`;
            document.getElementById('gameHud').style.opacity=0;
        }
        function updateUI() {
            const p = gameState.player;
            document.getElementById('playerHpBar').style.width = (p.hp/GAME_CONFIG.maxHp*100)+'%';
            document.getElementById('hpText').innerText = Math.ceil(p.hp)+'%';
            const bP = p.isBurstActive ? (p.burstTimer/GAME_CONFIG.burstDuration)*100 : p.burstGauge;
            document.getElementById('burstBarFill').style.height = bP+'%';
            document.getElementById('burstBtn').disabled = !(p.burstGauge>=100 && !p.isBurstActive);
            document.getElementById('weaponName').innerText = p.weapon.name;
            document.getElementById('weaponName').style.color = p.weapon.color;
            document.getElementById('ammoDisplay').innerText = Math.floor(p.ammo).toString().padStart(2,'0');
            document.getElementById('maxAmmoDisplay').innerText = p.maxAmmo;
            const reloadInd = document.getElementById('reloadIndicator');
            if(p.isHiding && p.ammo<p.maxAmmo) reloadInd.classList.remove('hidden'); else reloadInd.classList.add('hidden');
            if(gameState.boss) {
                document.getElementById('bossHpBar').style.width = (gameState.boss.hp/gameState.boss.maxHp*100)+'%';
                document.getElementById('bossHpPercent').innerText = Math.ceil(gameState.boss.hp/gameState.boss.maxHp*100)+'%';
            }
        }

        function switchWeapon(type) {
            const w = WEAPONS[type];
            gameState.player.weapon = w; gameState.player.maxAmmo = w.mag; gameState.player.ammo = w.mag;
            const el = document.createElement('div'); el.className='weapon-pickup-text'; el.innerText=`獲得武器: ${w.name}`;
            el.style.color=w.color; el.style.top='30%'; document.body.appendChild(el); setTimeout(()=>el.remove(), 1500);
        }
        function createDamageText(x,y,t,isCrit) {
            const el = document.createElement('div'); el.className='damage-text'; el.style.left=x+'px'; el.style.top=y+'px'; el.innerText=t;
            if(isCrit) { el.style.color='#facc15'; el.style.fontSize='40px'; }
            document.body.appendChild(el); setTimeout(()=>el.remove(), 600);
        }
        function createParticle(x, y, type) {
             if(type==='explosion') gameState.particles.push({x,y,type,life:20,size:10});
             else if(type==='spark' || type==='blood') {
                 for(let i=0;i<5;i++) gameState.particles.push({x,y,type,life:15,vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,size:3,color:type==='blood'?'#ef4444':'#06b6d4'});
             }
        }
        function updateParticles() {
            gameState.particles.forEach((p,i)=>{
                p.life--;
                if(p.type!=='explosion'){ p.x+=p.vx; p.y+=p.vy; } else { p.size+=2; }
                if(p.life<=0) gameState.particles.splice(i,1);
            });
        }
        function drawParticles() {
            gameState.particles.forEach(p=>{
                CTX.fillStyle = p.type==='blood'?'#ef4444':(p.type==='explosion'?'orange':'#06b6d4');
                CTX.beginPath(); CTX.arc(p.x, p.y, p.size, 0, Math.PI*2); CTX.fill();
            });
        }

        function drawEnemy(e) {
            const s = e.scale; 
            CTX.save(); 
            CTX.translate(e.screenX, e.screenY);
            
            if(e.state==='aiming') {
                CTX.strokeStyle='rgba(239,68,68,0.3)';
                CTX.lineWidth = 1;
                CTX.beginPath(); CTX.moveTo(0,0); CTX.lineTo(CANVAS.width/2-e.screenX, CANVAS.height-160-e.screenY); CTX.stroke(); 
            }
            
            CTX.save(); CTX.rotate(e.rotation); CTX.strokeStyle = '#475569'; CTX.lineWidth = 3 * s; CTX.beginPath(); CTX.arc(0, 0, 40*s, 0, Math.PI*1.5); CTX.stroke(); CTX.restore();
            CTX.save(); CTX.rotate(-e.rotation * 1.5); CTX.strokeStyle = '#64748b'; CTX.lineWidth = 2 * s; CTX.beginPath(); CTX.arc(0, 0, 50*s, 0, Math.PI*1.2); CTX.stroke(); CTX.restore();
            CTX.fillStyle='#1e293b'; CTX.beginPath(); CTX.arc(0, 0, 25*s, 0, Math.PI*2); CTX.fill();
            const eyeColor = e.state==='attacking' ? '#ef4444' : (e.state==='aiming' ? '#f59e0b' : '#0ea5e9');
            CTX.fillStyle = eyeColor; CTX.shadowColor = eyeColor; CTX.shadowBlur = 10; CTX.beginPath(); CTX.arc(0, 0, 12*s, 0, Math.PI*2); CTX.fill(); CTX.shadowBlur = 0;
            CTX.fillStyle='rgba(0,0,0,0.5)'; CTX.fillRect(-30*s, -65*s, 60*s, 6*s);
            CTX.fillStyle='#ef4444'; CTX.fillRect(-30*s, -65*s, 60*s*(e.hp/e.maxHp), 6*s);
            
            CTX.restore();
        }

        function drawBoss(b) {
            CTX.save(); 
            CTX.translate(b.x, b.y);
            const pulse = Math.sin(gameState.frames * 0.05) * 5;
            CTX.fillStyle = '#1e293b'; CTX.strokeStyle = '#ef4444'; CTX.lineWidth = 2;
            CTX.beginPath(); CTX.moveTo(-80, -20); CTX.lineTo(-180, -60 + pulse); CTX.lineTo(-160, 40 + pulse); CTX.lineTo(-60, 20); CTX.fill(); CTX.stroke();
            CTX.beginPath(); CTX.moveTo(80, -20); CTX.lineTo(180, -60 + pulse); CTX.lineTo(160, 40 + pulse); CTX.lineTo(60, 20); CTX.fill(); CTX.stroke();
            CTX.fillStyle = '#0f172a'; CTX.beginPath(); CTX.moveTo(-60, -80); CTX.lineTo(60, -80); CTX.lineTo(80, 0); CTX.lineTo(50, 80); CTX.lineTo(-50, 80); CTX.lineTo(-80, 0); CTX.closePath(); CTX.fill(); CTX.stroke();
            CTX.fillStyle = '#7f1d1d'; CTX.beginPath(); CTX.arc(0, 0, 35, 0, Math.PI*2); CTX.fill();
            CTX.fillStyle = '#ef4444'; CTX.shadowColor = 'red'; CTX.shadowBlur = 20 + Math.abs(pulse)*2; CTX.beginPath(); CTX.arc(0, 0, 20, 0, Math.PI*2); CTX.fill();
            CTX.strokeStyle = 'rgba(255, 0, 0, 0.3)'; CTX.lineWidth = 2; CTX.beginPath(); CTX.moveTo(0, 0); CTX.lineTo(Math.sin(gameState.frames * 0.03) * 400, 800); CTX.stroke();
            CTX.restore();
        }

        function drawPlayer() {
            const cx = CANVAS.width/2; 
            const cy = CANVAS.height - 100;
            const p = gameState.player;
            CTX.fillStyle = '#0f172a'; CTX.fillRect(cx-100, cy-120, 200, 120);
            CTX.strokeStyle = '#38bdf8'; CTX.lineWidth = 2; CTX.strokeRect(cx-100, cy-120, 200, 120);
            CTX.save(); CTX.clip(new Path2D(`M${cx-100} ${cy-120} h200 v120 h-200 z`));
            CTX.strokeStyle = 'rgba(56, 189, 248, 0.1)'; CTX.lineWidth = 1;
            for(let i=0; i<200; i+=20) { CTX.beginPath(); CTX.moveTo(cx-100+i, cy-120); CTX.lineTo(cx-100+i, cy); CTX.stroke(); }
            CTX.restore();

            let charY = cy - 100; 
            if(!p.isHiding) charY -= 40; else charY += 20;
            const recoil = p.weaponHeat * 0.5;
            CTX.fillStyle = '#334155'; CTX.beginPath(); CTX.ellipse(cx, charY + 50, 40, 50, 0, 0, Math.PI * 2); CTX.fill();
            CTX.fillStyle = '#1e293b'; CTX.fillRect(cx - 20, charY + 30, 40, 40); CTX.strokeStyle = '#64748b'; CTX.lineWidth = 2; CTX.strokeRect(cx - 20, charY + 30, 40, 40);
            CTX.fillStyle = '#475569'; CTX.beginPath(); CTX.arc(cx - 45, charY + 40, 15, 0, Math.PI*2); CTX.fill(); CTX.beginPath(); CTX.arc(cx + 45, charY + 40, 15, 0, Math.PI*2); CTX.fill();
            CTX.fillStyle = '#1e293b'; CTX.beginPath(); CTX.arc(cx, charY, 30, 0, Math.PI * 2); CTX.fill();
            CTX.fillStyle = '#0ea5e9'; CTX.shadowColor = '#0ea5e9'; CTX.shadowBlur = 10; CTX.beginPath(); CTX.roundRect(cx - 20, charY - 5, 40, 15, 5); CTX.fill(); CTX.shadowBlur = 0;
            CTX.fillStyle = '#64748b'; CTX.fillRect(cx - 32, charY - 10, 6, 20); CTX.fillRect(cx + 26, charY - 10, 6, 20); 
            CTX.strokeStyle = '#94a3b8'; CTX.beginPath(); CTX.moveTo(cx+28, charY-10); CTX.lineTo(cx+28, charY-30); CTX.stroke();

            if(!p.isHiding) {
                const angle = Math.atan2(gameState.input.y - (charY + 40), gameState.input.x - cx);
                CTX.save(); CTX.translate(cx + 35, charY + 40 + recoil); CTX.rotate(angle);
                CTX.fillStyle = '#0f172a'; CTX.fillRect(0, -6, 70, 12);
                CTX.fillStyle = p.weapon.color; CTX.shadowColor = p.weapon.color; CTX.shadowBlur = 5; CTX.fillRect(10, -2, 50, 4); CTX.shadowBlur = 0;
                CTX.fillStyle = '#334155'; CTX.fillRect(70, -4, 5, 8);
                CTX.restore();
            }
        }

        // Draw Foreground Objects (Ruins)
        function drawForeground() {
             CTX.fillStyle = '#020617'; 
             CTX.beginPath(); CTX.moveTo(0, CANVAS.height); CTX.lineTo(0, CANVAS.height - 300); CTX.lineTo(50, CANVAS.height - 320); CTX.lineTo(100, CANVAS.height - 250); CTX.lineTo(180, CANVAS.height - 280); CTX.lineTo(200, CANVAS.height); CTX.fill();
             CTX.beginPath(); CTX.moveTo(CANVAS.width, CANVAS.height); CTX.lineTo(CANVAS.width, CANVAS.height - 400); CTX.lineTo(CANVAS.width - 80, CANVAS.height - 350); CTX.lineTo(CANVAS.width - 120, CANVAS.height - 380); CTX.lineTo(CANVAS.width - 220, CANVAS.height - 200); CTX.lineTo(CANVAS.width - 180, CANVAS.height); CTX.fill();
        }

        // Draw Midground Debris (Replaced Rocks)
        function drawDebris() {
            const focalLength = 600;
            const cy = CANVAS.height / 2;
            const cx = CANVAS.width / 2;

            for (let obj of MIDGROUND_DEBRIS) {
                const scale = focalLength / (focalLength + obj.z);
                const sx = cx + obj.x * scale;
                const sy = cy + obj.y * scale; // Ground level contact point
                const w = obj.width * scale;
                const h = obj.height * scale;

                if (sy > CANVAS.height + h) continue;

                CTX.save();
                CTX.translate(sx, sy);
                CTX.rotate(obj.rotation);
                
                // Draw Upwards from contact point (0, 0)
                // Main block
                CTX.fillStyle = obj.color;
                CTX.beginPath();
                CTX.moveTo(-w/2, 0); // Bottom Left
                CTX.lineTo(-w/2 + 5 * scale, -h); // Top Left (Slight skew)
                // Jagged Top
                CTX.lineTo(-w/4, -h + 5 * scale);
                CTX.lineTo(0, -h - 5 * scale);
                CTX.lineTo(w/4, -h + 2 * scale);
                CTX.lineTo(w/2 - 5 * scale, -h); // Top Right
                CTX.lineTo(w/2, 0); // Bottom Right
                CTX.closePath();
                CTX.fill();

                // Highlight/Texture details
                CTX.strokeStyle = 'rgba(255,255,255,0.05)';
                CTX.lineWidth = 2 * scale;
                CTX.beginPath();
                CTX.moveTo(-w/2 + 5 * scale, -5 * scale);
                CTX.lineTo(-w/2 + 5 * scale, -h + 5 * scale);
                CTX.stroke();

                CTX.restore();
            }
        }

        function draw() {
            CTX.fillStyle = '#0f172a'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height);
            CTX.save();
            if(gameState.cameraShake>0) CTX.translate((Math.random()-0.5)*gameState.cameraShake, (Math.random()-0.5)*gameState.cameraShake);
            
            drawBackground();
            
            // Draw Order: Background -> Boss -> Debris -> Drops -> Enemies -> Foreground -> Player -> UI
            if(gameState.boss) drawBoss(gameState.boss);
            drawDebris();
            gameState.drops.forEach(d=>d.draw());
            
            gameState.enemies.forEach(e=> {
                if(!e.isOccluded) drawEnemy(e); 
            });

            drawForeground();

            gameState.projectiles.forEach(p=>p.draw());
            drawPlayer();
            drawParticles();
            
            if(gameState.player.weapon.chargeTime && gameState.player.currentWeaponCharge > 0) {
                 const x = gameState.input.x + gameState.input.currentRecoilX;
                 const y = gameState.input.y + gameState.input.currentRecoilY;
                 CTX.beginPath(); CTX.arc(x,y, 40, -Math.PI/2, -Math.PI/2 + Math.PI*2*gameState.player.currentWeaponCharge);
                 CTX.strokeStyle = '#f97316'; CTX.lineWidth=3; CTX.stroke();
            }
            CTX.restore();
        }

        function drawBackground() {
            let cx = CANVAS.width/2; let cy = CANVAS.height/2;
            let skyGrad = CTX.createLinearGradient(0, 0, 0, CANVAS.height * 0.6);
            skyGrad.addColorStop(0, '#0f172a'); skyGrad.addColorStop(0.5, '#4c1d95'); skyGrad.addColorStop(1, '#c2410c');
            CTX.fillStyle = skyGrad; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            CTX.fillStyle = '#1e1b4b'; 
            for(let i = -5; i <= 5; i++) {
                let x = cx + i * 250; let h = 150 + Math.abs(Math.sin(i * 123)) * 100; 
                CTX.beginPath(); CTX.moveTo(x - 100, CANVAS.height); CTX.lineTo(x - 100, cy - h * 0.5); 
                CTX.lineTo(x - 80, cy - h); CTX.lineTo(x, cy - h + 20); CTX.lineTo(x + 50, cy - h - 10); CTX.lineTo(x + 100, cy - h * 0.8); CTX.lineTo(x + 100, CANVAS.height); CTX.fill();
            }

            let groundGrad = CTX.createLinearGradient(0, cy, 0, CANVAS.height);
            groundGrad.addColorStop(0, '#1e1b4b'); groundGrad.addColorStop(1, '#020617'); 
            CTX.fillStyle = groundGrad; CTX.fillRect(0, cy, CANVAS.width, CANVAS.height - cy);

            CTX.strokeStyle = 'rgba(255, 255, 255, 0.05)'; CTX.lineWidth = 2; CTX.beginPath();
            for(let i = -10; i <= 10; i++) { CTX.moveTo(cx, cy); CTX.lineTo(cx + i * 500, CANVAS.height); }
            for(let i = 0; i < 20; i++) { let y = cy + Math.pow(i, 2.5); if (y > CANVAS.height) break; CTX.moveTo(0, y); CTX.lineTo(CANVAS.width, y); }
            CTX.stroke();
        }

        init();
    </script>
</body>
</html>